Heap : 완전 이진 트리 

* 완전 이진 트리라는 것은 잘생긴 트리라는 것.
이는 트리의 모양이 왼쪽부터 채워지는 것을 의미한다.
예를 들어 노드가 4개 있을 경우, 그냥 이진 트리라면 최대 4개의 층에 걸쳐 존재할 수 있지만
heap의 경우에는 첫 층에 루트 노드가 존재하고, 두번째 층에 루트의 child node가 2개 존재하고,
세번째 층에는 root의 left child의 left child 노드가 존재해 왼쪽부터 채워지는 트리이다.


MAX heap : 부모노드의 값이 자식노드보다 크다. 최대값을 빠르게 구할 때 사용
MIN heap : 부모노드의 값이 자식노드보다 작다. 최소값을 빠르게 구할 경우 사용된다.

heapify : 해당 트리를 heap으로 만드는 과정.

* 힙 구현 시 배열을 사용하면 0번 인덱스는 편의를 위해 사용하지 않는다.

* 힙은 우선순위 큐 구현에 많이 사용된다.
* 우선순위 큐 :  보통 큐는 들어온 순서에 따라 출력이 되지만,
우선순위 큐에서는 우선순위에 따라 나가게 된다.
이 때, 우선순위 큐는 배열이나 연결 리스트, 힙을 이용해 구현이 가능하다.
다만, 배열이나 연결 리스트를 사용할 경우에 일일이 비교하는 과정이 필요하므로 비효율적인 문제가 있다.

* 이 heap을 이용해 정렬한 다음 데이터를 모두 추출하는 과정을 통해 sort가 가능하다.
이를 heap sort라고 한다.

heap 구현

- 처음에 리스트가 주어졌을 때, 이 리스트를 heap에 맞춰 정렬하는 과정이 필요하다.
이 과정이 heapify하는 과정
heapify 구현 과정
1. 맨 처음 시작은 맨 마지막 노드의 부모 노드부터 시작한다.
2. 맨 처음 들어온 리스트는 heap에 맞춰 정렬되지 않았으므로 모든 노드를 돌면서 확인해야 한다.
3. 1에서 자식 둘의 값과 비교해 큰 값이 있는지 확인한다. 있다면, 둘의 위치를 swap한다.
4. 3 이후에 바뀐 자식의 위치에서 다시 그 아래 자식들과 비교해 3의 과정을 반복한다.
5. 2~4의 과정을 맨 앞 노드까지 반복한다.

데이터 삽입 구현 과정 
1. heap사이즈를 1 증가시킨다.
2. 맨 마지막 위치에 현재 데이터를 삽입한다.
3. 여기서 heap은 이미 정렬된 상태라고 가정하고, 맨 마지막 노드와 그 부모의 노드값을 비교한다.
4. 부모 노드가 새로 들어온 값보다 크다면 종료하고, 아니라면 값을 swap한다. 이후 위로 올라가면서 
3의 과정을 반복한다.

데이터 삭제 구현 과정
1. heap[1]의 데이터는 가장 큰 값이므로 이 값을 저장해둔다.
2. 맨 끝에 있던 데이터는 heap[1] 위치로 이동시킨다.
3. 그리고 이동한 heap[1]을 위치에 맞게 이동시키는 과정이 필요한데, 이는 그 자식들과 비교해
부모가 큰 값이 나올 때까지 계속해서 자식들과 값을 바꾸는 과정을 반복한다.
4. 3이 끝난 후 heap사이즈를 하나 감소시킨다.
5. 1값을 되돌려준다.