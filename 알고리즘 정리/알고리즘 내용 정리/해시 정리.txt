해시
- 고속 검색에 사용된다.
- key-value 쌍으로 이루어져 있다. 찾는 값을 인자로 넘겨주면 이 값을 key값으로 바꿔주는데
이 함수를 hash function이라고 한다.
- 보통 배열이나 다른 리스트 같은 경우에는 찾기 위해 O(n)의 시간복잡도를 가지는 검색이 필요했는데
이 해시는 O(1)로 원하는 값을 찾을 수 있다.

- Direct Addressing table : 입력된 key-value 쌍을 이용해 key값을 직접적으로 인덱스로 활용해 값을 저장
해시 테이블
- 해시 함수를 이용해 찾은 키 값을 이용해 기존 값을 저장하는 공간. 
- key를 이용해 해당 인덱스를 찾고 그 위치에 현재 데이터를 저장

해시 문제점

- collision(충돌) : 해시 함수 적용 시 다른 값으로 계산한 키 값이 서로 같은 값으로 나올 수 있다.
  이 문제 해결을 위해 사용되는 방법에는
 * chaining 방식 : 서로 같은 key값 뒤에 리스트나 배열을 이어붙이는 방식. 해시 값의 충돌이 일어날 
경우 해당 위치에 있는 값 뒤에 현재 값을 삽입.

density(적재률) : 현 해시 테이블 공간에서 실제 활용중인 공간. 현재 저장된 인덱스 개수/전체 인덱스 개수
이 값이 낮을수록 충돌의 확률이 올라감. 따라서 좋은 해시 함수를 만드는 방법은 simple uniform hash를 
구현하는 것이다. 이는 충돌을 최소화하는 hash function을 만드는 것이다. 

-open addressing : 기존 key값을 테이블 저장하는 기존의 방식과는 달리, 모든 데이터를 테이블에 저장하는
방식이다. 데이터를 직접 테이블에서 모두 읽기 때문에 포인터 사용할 일이 없다. 
기존에는 collision을 방지하기 위해 chaining 방식을 사용하곤 했으나 이 방식에서는 충돌이 일어날 경우
충돌이 일어난 다음 인덱스에 저장한다.
* 참고로 이 방식에서는 데이터의 수가 해시 테이블보다 작아야 한다. 초과되는 경우는 저장이 불가능하기 때문.

 이 방식에서 삽입,삭제,탐색을 위해 probing 방식을 사용.
probing은 해시 테이블 내 원하는 값을 찾는 과정을 말한다.

linear probing : 충돌이 일어날 경우, 인덱스를 1씩 증가시키면서 탐색하는 방식.
Quadratic probing : 충돌이 일어날 경우, 특정 수의 제곱씩 인덱스를 증가시키면서 탐색하는 방식.

이중해싱(double hashing)은 탐사할 해시값의 규칙성을 없애버려서 clustering을 방지하는 기법입니다. 
2개의 해시함수를 준비해서 하나는 최초의 해시값을 얻을 때, 
또 다른 하나는 해시충돌이 일어났을 때 탐사 이동폭을 얻기 위해 사용합니다.
 이렇게 되면 최초 해시값이 같더라도 탐사 이동폭이 달라지고,
 탐사 이동폭이 같더라도 최초 해시값이 달라져 primary, secondary clustering을 모두 완화할 수 있습니다.

