#define max_size 9999999
struct edge
{
	int ver;
	int weight;
	struct edge* next;
};
struct node
{
	int vertex;
	struct edge* con;
};
struct dijkstra
{
	int ver;
	int weight;
	int prev;
};
struct node* graph = 0;
struct dijkstra* table = 0;
struct dijkstra* heap = 0;
int heap_point = 0;
int num1, num2;
int already_exist(int ver, int data)
{
	struct edge* cur = graph[ver].con;
	while (cur != 0)
	{
		if (cur->ver == data)	return 1;
		cur = cur->next;
	}
	return 0;
}
void addEdge(int src, int dst, int weight)
{
	int idx = src - 1;
	if (already_exist(idx, dst) == 1)	return;
	struct edge* new1 = (struct edge*)malloc(sizeof(struct edge));
	
	new1->ver = dst;
	new1->next = 0;
	new1->weight = weight;

	if (graph[idx].con == 0)
	{
		graph[idx].con = new1;
	}
	else
	{
		struct edge* cur = graph[idx].con;
		while (cur->next != 0)
		{
			cur = cur->next;
		}
		cur->next = new1;
	}
}
void add2heap(struct dijkstra data)
{
	int cur, parent;
	heap_point++;
	heap[heap_point] = data;
	cur = heap_point;
	while (1)
	{
		parent = cur / 2;
		if (parent<1 || heap[cur].weight>heap[parent].weight)	break;
		else {
			struct dijkstra tmp = heap[parent];
			heap[parent] = heap[cur];
			heap[cur] = tmp;
			cur = parent;
		}
	}
}
int pop_heap()
{
	if (heap_point == 0)	return -1;
	struct dijkstra ret = heap[1];
	int cur = 1;
	heap[1] = heap[heap_point];
	heap_point--;
	while (1)
	{
		int min = cur;
		int left = cur * 2;
		int right = left + 1;
		if (left <= heap_point && heap[left].weight < heap[min].weight)
		{
			min = left;
		}
		if (right <= heap_point && heap[right].weight < heap[min].weight)
		{
			min = right;
		}
		if (min == cur)	break;
		else {
			struct dijkstra tmp = heap[min];
			heap[min] = heap[cur];
			heap[cur] = tmp;
			cur = min;
		}
	}
	return ret.ver - 1;
}
void fix_table(int idx)
{
	struct edge* cur = graph[idx].con;
	while (cur != 0)
	{
		int table_idx = cur->ver - 1;
		if (table[table_idx].weight > table[idx].weight + cur->weight)
		{
			table[table_idx].weight = table[idx].weight + cur->weight;
			table[table_idx].prev = idx + 1;
			add2heap(table[table_idx]);
		}
		cur = cur->next;
	}
}
void print_result()
{
	for (int i = 0; i < num1; i++)
	{
		if (table[i].weight == max_size) {
			printf("INF\n");
		}
		else {
			printf("%d\n", table[i].weight);
		}
	}
}
void do_dijkstra(int src)
{
	table = (struct dijkstra*)malloc(sizeof(struct dijkstra) * num1);
	heap = (struct dijkstra*)malloc(sizeof(struct dijkstra) * num2);
	for (int i = 0; i < num1; i++)
	{
		table[i].ver = i + 1;
		table[i].prev = 0;
		table[i].weight = max_size;
	}
	table[src - 1].weight = 0;
	add2heap(table[src - 1]);
	while (1)
	{
		int idx = pop_heap();
		if (idx == -1)	break;
		fix_table(idx);
	}
	print_result();
}
int main()
{
	int start;
	scanf("%d %d", &num1, &num2);
	graph = (struct node*)malloc(sizeof(struct node) * num1);
	for (int i = 0; i < num1; i++)
	{
		graph[i].vertex = i + 1;
		graph[i].con = 0;
	}
	scanf("%d", &start);
	for (int i = 0; i < num2; i++)
	{
		int src, dst, w;
		scanf("%d %d %d", &src, &dst, &w);
		addEdge(src, dst, w);
	}
	do_dijkstra(start);
	return 0;

}
